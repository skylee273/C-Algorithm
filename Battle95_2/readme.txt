시간 : 14개 테스트케이스를 합쳐서 C/C++의 경우 1초 / Java의 경우 2초
메모리 : 힙, 정적 메모리 합쳐서 256MB 이내, 스택 메모리 1MB 이내

※ SW expert 아카데미의 문제를 무단 복제하는 것을 금지합니다.
나삼성씨는 길이 n의 배열이 주어질 때, 이 배열을 연속된 부분배열들로 적당히 분할해서
각 부분 배열이 같거나 증가하는 오름차순이거나 같거나 감소하는 내림차순으로 정렬되어 있기를 원한다.
나삼성씨는 부분 배열의 분할 개수를 최소로 하고 싶다. 배열을 최소 몇 개로 분할해야 목적을 이룰 수 있을까?

[입력]
첫 번째 줄에 테스트 케이스의 수 TC가 주어진다.
이후 TC개의 테스트 케이스가 새 줄로 구분되어 주어진다.
각 테스트 케이스는 다음과 같이 구성되었다.
첫 번째 줄에 배열의 크기 n이 주어진다. (1 ≤ n ≤ 100,000)
이후 배열을 이루는 n개의 정수 ai가 주어진다. (1 ≤ ai ≤ 109)

[출력]
각 테스트 케이스마다 ‘#x’(x는 테스트케이스 번호를 의미하며 1부터 시작한다)를 출력하고,
각 테스트 케이스마다 한 줄씩 민규가 분할해서 만들어야 하는 최소 배열의 개수를 출력하라.


[예제 풀이]
첫 번째 예제 - [ 1 1 1 1 ] 이 이미 같거나 오름차순 또는 같거나 내림차순으로 정렬되어 있다.
두 번째 예제 - [ 1 2 ] [ 4 3 3 1 ] 또는 [ 1 2 4 ] [ 3 3 1 ] 로 2개의 배열로 분할 할 수 있다.
세 번째 예제 - [ 1 ] [ 2 1 ] [ 2 1 ] [ 2 1 ] [ 2 1 ] 또는 [ 1 2 ] [ 1 2 ] [ 1 2 ] [ 1 2 ] [ 1 ] 로 5개의 배열로 분할 할 수 있다. 

[잘못된 풀이]
처음 시도했던것은 dfs 방법으로 모든 노드를 순회하면서 가능성을 찾음 그다음 시도한 것은 backtraking 으로 유망하지 않은 노드는 제거하면서 
시도했음 하지만 backtraking 을 사용하더라도 잘못된 길을 들어가봐야 하기 때문에 런타임 오류 시간 초과가 발생하는 문제가 생김
세번째로 생각한 풀이 for 문 한번에 해결해야겠다 총 숫자들이 연결되어 있다고 생각함 9개의 경우 8가지 선이 있음 오름차순 에서 내림차순 
내림차순에서 오름차순으로 바뀔때마다 분기를 표시함 그다음 앞 뒤를 볼때는 다시 맨 처음 상태처럼 오름차순 내림차순이 설정 되어 있다고 판단하지 
않고 다시 오름 차순 내림차순으로 할지 선택만 해줌 이렇게하면 연결된 선을 끊을 수 있는 개수가 나옴 끊은 개수 + 1 을 하면 분할 개수가 출력됨
